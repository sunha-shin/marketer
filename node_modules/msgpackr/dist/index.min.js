(function(a,b){"object"==typeof exports&&"undefined"!=typeof module?b(exports):"function"==typeof define&&define.amd?define(["exports"],b):(a=a||self,b(a.msgpackr={}))})(this,function(a){'use strict';var b=Math.floor;function c(){try{if(!G.trusted&&!N){let a=B.sharedLength||0;a<B.length&&(B.length=a)}let a=e();if(F==A)B.restoreStructures&&d(),B=null,z=null,D&&(D=null);else if(F>A){// over read
let a=new Error("Unexpected end of MessagePack data");throw a.incomplete=!0,a}else if(!N)throw new Error("Data read, but end of buffer not reached");// else more to read, but we are reading sequentially, so don't clear source yet
return a}catch(a){throw B.restoreStructures&&d(),p(),(a instanceof RangeError||a.message.startsWith("Unexpected end of buffer"))&&(a.incomplete=!0),a}}function d(){for(let a in B.restoreStructures)B[a]=B.restoreStructures[a];B.restoreStructures=null}function e(){let a=z[F++];if(160>a){if(!(128>a)){if(!(144>a)){a-=144;let b=Array(a);for(let c=0;c<a;c++)b[c]=e();return b}if(a-=128,G.mapsAsObjects){let b={};for(let c=0;c<a;c++)b[n()]=e();return b}else{let b=new Map;for(let c=0;c<a;c++)b.set(e(),e());return b}}else if(64>a)return a;else{let b=B[63&a];if(b)return b.read||(b.read=f(b,63&a)),b.read();if(G.getStructures){let c=o(()=>(z=null,G.getStructures()));return B=G._mergeStructures(c,B),b=B[63&a],b?(b.read||(b.read=f(b,63&a)),b.read()):a}return a}}else if(192>a){// fixstr
let b=a-160;if(I>=F)return C.slice(F-H,(F+=b)-H);if(0==I&&140>A){// for small blocks, avoiding the overhead of the extract call is helpful
let a=16>b?k(b):j(b);if(null!=a)return a}return R(b)}else{let b;switch(a){case 192:return null;case 193:return M;// "never-used", return special object to denote that
case 194:return!1;case 195:return!0;case 196:// bin 8
return l(z[F++]);case 197:return b=E.getUint16(F),F+=2,l(b);case 198:return b=E.getUint32(F),F+=4,l(b);case 199:// ext 8
return m(z[F++]);case 200:return b=E.getUint16(F),F+=2,m(b);case 201:return b=E.getUint32(F),F+=4,m(b);case 202:if(b=E.getFloat32(F),2<G.useFloat32){// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
let a=$[(127&z[F])<<1|z[F+1]>>7];return F+=4,(a*b+(0<b?.5:-.5)>>0)/a}return F+=4,b;case 203:return b=E.getFloat64(F),F+=8,b;// uint handlers
case 204:return z[F++];case 205:return b=E.getUint16(F),F+=2,b;case 206:return b=E.getUint32(F),F+=4,b;case 207:return G.uint64AsNumber?72057594037927940*z[F++]+281474976710656*z[F++]+1099511627776*z[F++]+4294967296*z[F++]+16777216*z[F++]+(z[F++]<<16)+(z[F++]<<8)+z[F++]:(b=E.getBigUint64(F),F+=8,b);// int handlers
case 208:return E.getInt8(F++);case 209:return b=E.getInt16(F),F+=2,b;case 210:return b=E.getInt32(F),F+=4,b;case 211:return b=E.getBigInt64(F),F+=8,b;case 212:if(b=z[F++],114==b)return X(63&z[F++]);else{let a=J[b];if(a)return a.read?(F++,a.read(e())):a.noBuffer?(F++,a()):a(z.subarray(F,++F));throw new Error("Unknown extension "+b)}case 213:return b=z[F],114==b?(F++,X(63&z[F++],z[F++])):m(2);case 214:// fixext 4
return m(4);case 215:// fixext 8
return m(8);case 216:// fixext 16
return m(16);case 217:return b=z[F++],I>=F?C.slice(F-H,(F+=b)-H):S(b);case 218:return b=E.getUint16(F),F+=2,I>=F?C.slice(F-H,(F+=b)-H):T(b);case 219:return b=E.getUint32(F),F+=4,I>=F?C.slice(F-H,(F+=b)-H):U(b);case 220:return b=E.getUint16(F),F+=2,h(b);case 221:return b=E.getUint32(F),F+=4,h(b);case 222:return b=E.getUint16(F),F+=2,i(b);case 223:return b=E.getUint32(F),F+=4,i(b);default:// negative int
if(224<=a)return a-256;if(void 0===a){let a=new Error("Unexpected end of MessagePack data");throw a.incomplete=!0,a}throw new Error("Unknown MessagePack token "+a);}}}function f(a,b){function c(){// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function
if(2<c.count++){let c=a.read=new Function("r","return function(){return {"+a.map(a=>P.test(a)?a+":r()":"["+JSON.stringify(a)+"]:r()").join(",")+"}}")(e);return 0===a.highByte&&(a.read=Q(b,a.read)),c();// second byte is already read, if there is one so immediately read object
}let d={};for(let b,c=0,f=a.length;c<f;c++)b=a[c],d[b]=e();return d}return c.count=0,0===a.highByte?Q(b,c):c}function g(a){let b;if(16>a&&(b=k(a)))return b;if(64<a&&y)return y.decode(z.subarray(F,F+=a));const c=F+a,d=[];for(b="";F<c;){const a=z[F++];if(0==(128&a))d.push(a);else if(192==(224&a)){// 2 bytes
const b=63&z[F++];d.push((31&a)<<6|b)}else if(224==(240&a)){// 3 bytes
const b=63&z[F++],c=63&z[F++];d.push((31&a)<<12|b<<6|c)}else if(240==(248&a)){// 4 bytes
const b=63&z[F++],c=63&z[F++],e=63&z[F++];let f=(7&a)<<18|b<<12|c<<6|e;65535<f&&(f-=65536,d.push(55296|1023&f>>>10),f=56320|1023&f),d.push(f)}else d.push(a);4096<=d.length&&(b+=V.apply(String,d),d.length=0)}return 0<d.length&&(b+=V.apply(String,d)),b}function h(a){let b=Array(a);for(let c=0;c<a;c++)b[c]=e();return b}function i(a){if(G.mapsAsObjects){let b={};for(let c=0;c<a;c++)b[n()]=e();return b}else{let b=new Map;for(let c=0;c<a;c++)b.set(e(),e());return b}}function j(a){let b=F,c=Array(a);for(let d=0;d<a;d++){const a=z[F++];if(0<(128&a))return void(F=b);c[d]=a}return V.apply(String,c)}function k(p){if(4>p){if(!(2>p)){let d=z[F++],a=z[F++];if(0<(128&d)||0<(128&a))return void(F-=2);if(3>p)return V(d,a);let b=z[F++];return 0<(128&b)?void(F-=3):V(d,a,b)}if(0===p)return"";else{let b=z[F++];return 1<(128&b)?void(F-=1):V(b)}}else{let q=z[F++],a=z[F++],b=z[F++],c=z[F++];if(0<(128&q)||0<(128&a)||0<(128&b)||0<(128&c))return void(F-=4);if(6>p){if(4===p)return V(q,a,b,c);else{let d=z[F++];return 0<(128&d)?void(F-=5):V(q,a,b,c,d)}}else if(8>p){let d=z[F++],e=z[F++];if(0<(128&d)||0<(128&e))return void(F-=6);if(7>p)return V(q,a,b,c,d,e);let f=z[F++];return 0<(128&f)?void(F-=7):V(q,a,b,c,d,e,f)}else{let d=z[F++],e=z[F++],f=z[F++],g=z[F++];if(0<(128&d)||0<(128&e)||0<(128&f)||0<(128&g))return void(F-=8);if(10>p){if(8===p)return V(q,a,b,c,d,e,f,g);else{let h=z[F++];return 0<(128&h)?void(F-=9):V(q,a,b,c,d,e,f,g,h)}}else if(12>p){let h=z[F++],i=z[F++];if(0<(128&h)||0<(128&i))return void(F-=10);if(11>p)return V(q,a,b,c,d,e,f,g,h,i);let j=z[F++];return 0<(128&j)?void(F-=11):V(q,a,b,c,d,e,f,g,h,i,j)}else{let h=z[F++],i=z[F++],j=z[F++],k=z[F++];if(0<(128&h)||0<(128&i)||0<(128&j)||0<(128&k))return void(F-=12);if(!(14>p)){let l=z[F++],m=z[F++];if(0<(128&l)||0<(128&m))return void(F-=14);if(15>p)return V(q,a,b,c,d,e,f,g,h,i,j,k,l,m);let n=z[F++];return 0<(128&n)?void(F-=15):V(q,a,b,c,d,e,f,g,h,i,j,k,l,m,n)}if(12===p)return V(q,a,b,c,d,e,f,g,h,i,j,k);else{let l=z[F++];return 0<(128&l)?void(F-=13):V(q,a,b,c,d,e,f,g,h,i,j,k,l)}}}}}function l(a){return G.copyBuffers?// specifically use the copying slice (not the node one)
Uint8Array.prototype.slice.call(z,F,F+=a):z.subarray(F,F+=a)}function m(a){let b=z[F++];if(J[b])return J[b](z.subarray(F,F+=a));throw new Error("Unknown extension type "+b)}function n(){let a=z[F++];if(160<=a&&192>a){if(a-=160,I>=F)// if it has been extracted, must use it (and faster anyway)
return C.slice(F-H,(F+=a)-H);if(!(0==I&&180>A))return R(a)}else return F--,e();let b,c=4095&(a<<5^(1<a?E.getUint16(F):0<a?z[F]:0)),d=W[c],f=F,g=F+a-3,h=0;if(d&&d.bytes==a){for(;f<g;){if(b=E.getUint32(f),b!=d[h++]){f=1879048192;break}f+=4}for(g+=3;f<g;)if(b=z[f++],b!=d[h++]){f=1879048192;break}if(f===g)return F=f,d.string;g-=3,f=F}for(d=[],W[c]=d,d.bytes=a;f<g;)b=E.getUint32(f),d.push(b),f+=4;for(g+=3;f<g;)b=z[f++],d.push(b);// for small blocks, avoiding the overhead of the extract call is helpful
let l=16>a?k(a):j(a);return null==l?d.string=R(a):d.string=l}// the registration of the record definition extension (as "r")
// notepack defines extension 0 to mean undefined, so use that as the default here
// registration of bulk record definition?
// currentExtensions[0x52] = () =>
function o(a){let b=A,c=F,d=H,e=I,f=C,g=D,h=new Uint8Array(z.slice(0,A)),i=B,j=B.slice(0,B.length),k=G,l=N,m=a();return A=b,F=c,H=d,I=e,C=f,D=g,z=h,N=l,B=i,B.splice(0,B.length,...j),G=k,E=new DataView(z.buffer,z.byteOffset,z.byteLength),m}function p(){z=null,D=null,B=null}function q(a){J[a.type]=a.unpack?a.unpack:a}function r(a,b,c){let d=a.byteLength;if(256>d+1){var{target:e,position:f}=c(4+d);e[f++]=199,e[f++]=d+1}else if(65536>d+1){var{target:e,position:f}=c(5+d);e[f++]=200,e[f++]=d+1>>8,e[f++]=255&d+1}else{var{target:e,position:f,targetView:g}=c(7+d);// plus one for the type byte
e[f++]=201,g.setUint32(f,d+1),f+=4}// "t" for typed array
e[f++]=116,e[f++]=b,e.set(new Uint8Array(a.buffer,a.byteOffset,a.byteLength),f)}function s(a,b){let c=a.byteLength;var d,e;if(256>c){var{target:d,position:e}=b(c+2);d[e++]=196,d[e++]=c}else if(65536>c){var{target:d,position:e}=b(c+3);d[e++]=197,d[e++]=c>>8,d[e++]=255&c}else{var{target:d,position:e,targetView:f}=b(c+5);d[e++]=198,f.setUint32(e,c),e+=4}d.set(a,e)}function t(a,b,c,d){let e=a.length;return 1===e?b[c++]=212:2===e?b[c++]=213:4===e?b[c++]=214:8===e?b[c++]=215:16===e?b[c++]=216:256>e?(b[c++]=199,b[c++]=e):65536>e?(b[c++]=200,b[c++]=e>>8,b[c++]=255&e):(b[c++]=201,b[c++]=e>>24,b[c++]=255&e>>16,b[c++]=255&e>>8,b[c++]=255&e),b[c++]=d,b.set(a,c),c+=e,c}function u(a,b){// insert the ids that need to be referenced for structured clones
let c,d=6*b.length,e=a.length-d;for(b.sort((c,a)=>c.offset>a.offset?1:-1);c=b.pop();){let b=c.offset,f=c.id;a.copyWithin(b+d,b,e),d-=6;let g=b+d;// 'i'
a[g++]=214,a[g++]=105,a[g++]=f>>24,a[g++]=255&f>>16,a[g++]=255&f>>8,a[g++]=255&f,e=b}return a}function v(a){if(a.Class){if(!a.pack&&!a.write)throw new Error("Extension has no pack or write function");if(a.pack&&!a.type)throw new Error("Extension has no type (numeric code to identify the extension)");ga.unshift(a.Class),fa.unshift(a)}q(a)}function*w(a,b){const c=new qa(b);for(const d of a)yield c.pack(d)}async function*x(a,b){const c=new qa(b);for await(const d of a)yield c.pack(d)}/**
	 * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects
	 * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.
	 * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator
	 * @param {object} [options] - unpackr options
	 * @returns {IterableIterator|Promise.<AsyncIterableIterator}
	 */var y;try{y=new TextDecoder}catch(a){}var z,A,B,C,D,E,F=0,G={},H=0,I=0,J=[],K={useRecords:!1,mapsAsObjects:!0};class L{}const M=new L;M.name="MessagePack 0xC1";var N=!1;class O{constructor(a){a&&(!1===a.useRecords&&a.mapsAsObjects===void 0&&(a.mapsAsObjects=!0),a.structures?a.structures.sharedLength=a.structures.length:a.getStructures&&((a.structures=[]).uninitialized=!0,a.structures.sharedLength=0)),Object.assign(this,a)}unpack(a,b){if(z)// re-entrant execution, save the state and restore it after we do this unpack
return o(()=>(p(),this?this.unpack(a,b):O.prototype.unpack.call(K,a,b)));if(A=-1<b?b:a.length,F=0,I=0,C=null,z=a,E=a.dataView||(a.dataView=new DataView(a.buffer,a.byteOffset,a.byteLength)),this){if(G=this,this.structures)return B=this.structures,c();(!B||0<B.length)&&(B=[])}else G=K,(!B||0<B.length)&&(B=[]);return c()}unpackMultiple(a,b){let d,e=0;try{N=!0;let f=a.length,g=this?this.unpack(a,f):_.unpack(a,f);if(b){for(b(g);F<f;)if(e=F,!1===b(c()))return;}else{for(d=[g];F<f;)e=F,d.push(c());return d}}catch(a){throw a.lastPosition=e,a.values=d,a}finally{N=!1,p()}}_mergeStructures(a,b){a=a||[];for(let c,d=0,e=a.length;d<e;d++)c=a[d],c&&(c.isShared=!0,32<=d&&(c.highByte=d-32>>5));for(let c in a.sharedLength=a.length,b||[])if(0<=c){let d=a[c],e=b[c];e&&(d&&((a.restoreStructures||(a.restoreStructures=[]))[c]=d),a[c]=e)}return this.structures=a}decode(a,b){return this.unpack(a,b)}}const P=/^[a-zA-Z_$][a-zA-Z\d_$]*$/,Q=(a,b)=>function(){let c=z[F++];if(0===c)return b();let d=B[32>a?-(a+(c<<5)):a+(c<<5)];if(!d)throw new Error("Record id is not defined "+a.toString(16)+c.toString(16));return d.read||(d.read=f(d,a)),d.read()};var R=g,S=g,T=g,U=g,V=String.fromCharCode,W=Array(4096);const X=(a,b)=>{var c=e();let d=a;void 0!==b&&(a=32>a?-((b<<5)+a):(b<<5)+a,c.highByte=b);let g=B[a];return g&&g.isShared&&((B.restoreStructures||(B.restoreStructures=[]))[a]=g),B[a]=c,c.read=f(c,d),c.read()};var Y="object"==typeof window?window:global;J[0]=()=>{},J[0].noBuffer=!0,J[101]=()=>{let a=e();return(Y[a[0]]||Error)(a[1])},J[105]=()=>{// id extension (for structured clones)
let a=E.getUint32(F-4);D||(D=new Map);let b,c=z[F];b=144<=c&&160>c||220==c||221==c?[]:{};let d={target:b};// a placeholder object
D.set(a,d);let f=e();// read the next value as the target object to id
return d.used?Object.assign(b,f):(d.target=f,f);// no cycle, can just use the returned read object
},J[112]=()=>{// pointer extension (for structured clones)
let a=E.getUint32(F-4),b=D.get(a);return b.used=!0,b.target},J[115]=()=>new Set(e());const Z=["Int8","Uint8","Uint8Clamped","Int16","Uint16","Int32","Uint32","Float32","Float64","BigInt64","BigUint64"].map(a=>a+"Array");J[116]=a=>{let b=a[0],c=Z[b];if(!c)throw new Error("Could not find typed array for code "+b);// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned
return new Y[c](Uint8Array.prototype.slice.call(a,1).buffer)},J[120]=()=>{let a=e();return new RegExp(a[0],a[1])},J[255]=a=>{// 32-bit date extension
if(4==a.length)return new Date(1e3*(16777216*a[0]+(a[1]<<16)+(a[2]<<8)+a[3]));if(8==a.length)return new Date(((a[0]<<22)+(a[1]<<14)+(a[2]<<6)+(a[3]>>2))/1e6+1e3*(4294967296*(3&a[3])+16777216*a[4]+(a[5]<<16)+(a[6]<<8)+a[7]));if(12==a.length)// TODO: Implement support for negative
return new Date(((a[0]<<24)+(a[1]<<16)+(a[2]<<8)+a[3])/1e6+1e3*((128&a[4]?-281474976710656:0)+1099511627776*a[6]+4294967296*a[7]+16777216*a[8]+(a[9]<<16)+(a[10]<<8)+a[11]));throw new Error("Invalid timestamp length")};const $=Array(147);// this is a table matching binary exponents to the multiplier to determine significant digit rounding
for(let c=0;256>c;c++)$[c]=+("1e"+b(45.15-.30103*c));var _=new O({useRecords:!1});const aa=_.unpack,ba=_.unpackMultiple,ca=_.unpack,da={NEVER:0,ALWAYS:1,DECIMAL_ROUND:3,DECIMAL_FIT:4};let ea;try{ea=new TextEncoder}catch(a){}let fa,ga;const ha="undefined"!=typeof Buffer,ia=ha?Buffer.allocUnsafeSlow:Uint8Array,ja=ha?Buffer:Uint8Array,ka=ha?4294967296:2144337920;let la,ma,na,oa=0;const pa=Symbol("record-id");class qa extends O{constructor(a){super(a),this.offset=0;let b,c,d,e,f,g=0,h=ja.prototype.utf8Write?function(a,b,c){return la.utf8Write(a,b,c)}:!!(ea&&ea.encodeInto)&&function(a,b){return ea.encodeInto(a,la.subarray(b)).written},i=this;a||(a={});let j=a&&a.sequential,k=a.structures||a.saveStructures,l=a.maxSharedStructures??(k?32:0);if(8160<l)throw new Error("Maximum maxSharedStructure is 8160");let m=a.maxOwnStructures??(k?32:64);j&&!a.saveStructures&&(this.structures=[]);// two byte record ids for shared structures
let n=32<l||64<m+l,o=l+64,p=l+m+64;if(8256<p)throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192");let q=[],r=0,s=0;this.pack=this.encode=function(a){if(la||(la=new ia(8192),ma=new DataView(la.buffer,0,8192),oa=0),na=la.length-10,2048>na-oa?(la=new ia(la.length),ma=new DataView(la.buffer,0,la.length),na=la.length-10,oa=0):oa=2147483640&oa+7,b=oa,f=i.structuredClone?new Map:null,c=i.structures,c){c.uninitialized&&(c=i._mergeStructures(i.getStructures()));let a=c.sharedLength||0;if(a>l)//if (maxSharedStructures <= 32 && sharedStructures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids
throw new Error("Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to "+c.sharedLength);if(!c.transitions){c.transitions=Object.create(null);for(let b,d=0;d<a;d++){if(b=c[d],!b)continue;let a,e=c.transitions;for(let c,d=0,f=b.length;d<f;d++)c=b[d],a=e[c],a||(a=e[c]=Object.create(null)),e=a;e[pa]=d+64}g=a}j||(c.nextId=a+64)}d&&(d=!1),e=c||[];try{// update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially
if(v(a),i.offset=oa,f&&f.idsToInsert){oa+=6*f.idsToInsert.length,oa>na&&x(oa),i.offset=oa;let a=u(la.subarray(b,oa),f.idsToInsert);return f=null,a}return la.subarray(b,oa);// position can change if we call pack again in saveStructures, so we get the buffer now
}finally{if(c){if(10>s&&s++,1e4<r)c.transitions=null,s=0,r=0,0<q.length&&(q=[]);else if(0<q.length&&!j){for(let a=0,b=q.length;a<b;a++)q[a][pa]=0;q=[]}if(d&&i.saveStructures){let b=c.sharedLength||l;if(c.length>b&&(c=c.slice(0,b)),!1===i.saveStructures(c,g))return i._mergeStructures(i.getStructures()),i.pack(a);g=b}}}};const v=a=>{oa>na&&(la=x(oa));var c,d=typeof a;if("string"==d){let b,d=a.length;b=32>d?1:256>d?2:65536>d?3:5;let e=3*d;if(oa+e>na&&(la=x(oa+e)),64>d||!h){let e,f,g,h=oa+b;for(e=0;e<d;e++)f=a.charCodeAt(e),128>f?la[h++]=f:2048>f?(la[h++]=192|f>>6,la[h++]=128|63&f):55296==(64512&f)&&56320==(64512&(g=a.charCodeAt(e+1)))?(f=65536+((1023&f)<<10)+(1023&g),e++,la[h++]=240|f>>18,la[h++]=128|63&f>>12,la[h++]=128|63&f>>6,la[h++]=128|63&f):(la[h++]=224|f>>12,la[h++]=128|63&f>>6,la[h++]=128|63&f);c=h-oa-b}else c=h(a,oa+b,e);32>c?la[oa++]=160|c:256>c?(2>b&&la.copyWithin(oa+2,oa+1,oa+1+c),la[oa++]=217,la[oa++]=c):65536>c?(3>b&&la.copyWithin(oa+3,oa+2,oa+2+c),la[oa++]=218,la[oa++]=c>>8,la[oa++]=255&c):(5>b&&la.copyWithin(oa+5,oa+3,oa+3+c),la[oa++]=219,ma.setUint32(oa,c),oa+=4),oa+=c}else if("number"===d){if(a>>>0===a)64>a?la[oa++]=a:256>a?(la[oa++]=204,la[oa++]=a):65536>a?(la[oa++]=205,la[oa++]=a>>8,la[oa++]=255&a):(la[oa++]=206,ma.setUint32(oa,a),oa+=4);else if(a>>0===a)-32<=a?la[oa++]=256+a:-128<=a?(la[oa++]=208,la[oa++]=a+256):-32768<=a?(la[oa++]=209,ma.setInt16(oa,a),oa+=2):(la[oa++]=210,ma.setInt32(oa,a),oa+=4);else{let b;if(0<(b=this.useFloat32)&&4294967296>a&&-2147483648<=a){la[oa++]=202,ma.setFloat32(oa,a);let c;if(4>b||// this checks for  rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
(c=a*$[(127&la[oa])<<1|la[oa+1]>>7])>>0===c)return void(oa+=4);// move back into position for writing a double
oa--}la[oa++]=203,ma.setFloat64(oa,a),oa+=8}}else if("object"===d){if(!a)la[oa++]=192;else{if(f){let c=f.get(a);if(c){if(!c.id){let a=f.idsToInsert||(f.idsToInsert=[]);c.id=a.push(c)}return la[oa++]=214,la[oa++]=112,ma.setUint32(oa,c.id),void(oa+=4)}f.set(a,{offset:oa-b})}let d=a.constructor;if(d===Object)w(a,!0);else if(d===Array){c=a.length,16>c?la[oa++]=144|c:65536>c?(la[oa++]=220,la[oa++]=c>>8,la[oa++]=255&c):(la[oa++]=221,ma.setUint32(oa,c),oa+=4);for(let b=0;b<c;b++)v(a[b])}else if(d===Map){c=a.size,16>c?la[oa++]=128|c:65536>c?(la[oa++]=222,la[oa++]=c>>8,la[oa++]=255&c):(la[oa++]=223,ma.setUint32(oa,c),oa+=4);for(let[b,c]of a)v(b),v(c)}else{for(let b,c=0,d=fa.length;c<d;c++)if(b=ga[c],a instanceof b){let b=fa[c];if(b.write)return b.type&&(la[oa++]=212,la[oa++]=b.type,la[oa++]=0),void v(b.write.call(this,a));let d=la,e=ma,f=oa;la=null;let g;try{g=b.pack.call(this,a,a=>(la=d,d=null,oa+=a,oa>na&&x(oa),{target:la,targetView:ma,position:oa-a}),v)}finally{d&&(la=d,ma=e,oa=f,na=la.length-10)}return void(g&&(g.length+oa>na&&x(g.length+oa),oa=t(g,la,oa,b.type)))}// no extension found, write as object
w(a,!a.hasOwnProperty)}}}else if("boolean"===d)la[oa++]=a?195:194;else if("bigint"===d){if(a<BigInt(1)<<BigInt(63)&&a>=-(BigInt(1)<<BigInt(63)))la[oa++]=211,ma.setBigInt64(oa,a);else if(a<BigInt(1)<<BigInt(64)&&0<a)la[oa++]=207,ma.setBigUint64(oa,a);else// overflow
if(this.largeBigIntToFloat)la[oa++]=203,ma.setFloat64(oa,+a);else throw new RangeError(a+" was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64");oa+=8}else if("undefined"===d)this.encodeUndefinedAsNil?la[oa++]=192:(la[oa++]=212,la[oa++]=0,la[oa++]=0);else if("function"===d)v(this.writeFunction&&this.writeFunction());else throw new Error("Unknown type: "+d)},w=!1===this.useRecords?this.variableMapSize?a=>{// this method is slightly slower, but generates "preferred serialization" (optimally small for smaller objects)
let b=Object.keys(a),c=b.length;16>c?la[oa++]=128|c:65536>c?(la[oa++]=222,la[oa++]=c>>8,la[oa++]=255&c):(la[oa++]=223,ma.setUint32(oa,c),oa+=4);let d;for(let e=0;e<c;e++)v(d=b[e]),v(a[d])}:(a,c)=>{la[oa++]=222;// always using map 16, so we can preallocate and set the length afterwards
let d=oa-b;oa+=2;let e=0;for(let b in a)(c||a.hasOwnProperty(b))&&(v(b),v(a[b]),e++);la[d++ +b]=e>>8,la[d+b]=255&e}:/*	sharedStructures ?  // For highly stable structures, using for-in can a little bit faster
			(object, safePrototype) => {
				let nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))
				let objectOffset = position++ - start
				let wroteKeys
				for (let key in object) {
					if (safePrototype || object.hasOwnProperty(key)) {
						nextTransition = transition[key]
						if (!nextTransition) {
							nextTransition = transition[key] = Object.create(null)
							nextTransition.__keys__ = (transition.__keys__ || []).concat([key])
							/*let keys = Object.keys(object)
							if 
							let size = 0
							let startBranch = transition.__keys__ ? transition.__keys__.length : 0
							for (let i = 0, l = keys.length; i++) {
								let key = keys[i]
								size += key.length << 2
								if (i >= startBranch) {
									nextTransition = nextTransition[key] = Object.create(null)
									nextTransition.__keys__ = keys.slice(0, i + 1)
								}
							}
							makeRoom(position + size)
							nextTransition = transition[key]
							target.copy(target, )
							objectOffset
						}
						transition = nextTransition
						pack(object[key])
					}
				}
				let id = transition.id
				if (!id) {
					id = transition.id = structures.push(transition.__keys__) + 63
					if (sharedStructures.onUpdate)
						sharedStructures.onUpdate(id, transition.__keys__)
				}
				target[objectOffset + start] = id
			}*/a=>{let b,c=Object.keys(a),f=e.transitions||(e.transitions=Object.create(null)),g=0;for(let d,e=0,h=c.length;e<h;e++)d=c[e],b=f[d],b||(b=f[d]=Object.create(null),g++),f=b;let h=f[pa];if(h)96<=h&&n?(la[oa++]=(31&(h-=96))+96,la[oa++]=h>>5):la[oa++]=h;else{h=e.nextId,h||(h=64),h<o&&this.shouldShareStructure&&!this.shouldShareStructure(c)?(h=e.nextOwnId,!(h<p)&&(h=o),e.nextOwnId=h+1):(h>=p&&(// cycle back around
h=o),e.nextId=h+1);let a=c.highByte=96<=h&&n?h-96>>5:-1;f[pa]=h,e[h-64]=c,h<o?(c.isShared=!0,e.sharedLength=h-63,d=!0,0<=a?(la[oa++]=(31&h)+96,la[oa++]=a):la[oa++]=h):(0<=a?(la[oa++]=213,la[oa++]=114,la[oa++]=(31&h)+96,la[oa++]=a):(la[oa++]=212,la[oa++]=114,la[oa++]=h),g&&(r+=s*g),q.length>=m&&(q.shift()[pa]=0),q.push(f),v(c))}// now write the values
for(let b=0,d=c.length;b<d;b++)v(a[c[b]])},x=a=>{var c=Math.min,d=Math.round,e=Math.max;let f;if(16777216<a){// special handling for really large buffers
if(a-b>ka)throw new Error("Packed buffer would be larger than maximum buffer size");f=c(ka,4096*d(e((a-b)*(67108864<a?1.25:2),16777216)/4096))}else// faster handling for smaller buffers
f=(e(a-b<<2,la.length-1)>>12)+1<<12;let g=new ia(f);return ma=new DataView(g.buffer,0,f),la.copy?la.copy(g,0,b,a):g.set(la.slice(b,a)),oa-=b,b=0,na=g.length-10,la=g}}useBuffer(a){// this means we are finished using our own buffer and we can write over it safely
la=a,ma=new DataView(la.buffer,la.byteOffset,la.byteLength),oa=0}}ga=[Date,Set,Error,RegExp,ArrayBuffer,Object.getPrototypeOf(Uint8Array.prototype).constructor/*TypedArray*/,L],fa=[{pack(a,c){let d=a.getTime()/1e3;if((this.useTimestamp32||0===a.getMilliseconds())&&0<=d&&4294967296>d){// Timestamp 32
let{target:a,targetView:b,position:e}=c(6);a[e++]=214,a[e++]=255,b.setUint32(e,d)}else if(0<d&&17179869184>d){// Timestamp 64
let{target:b,targetView:e,position:f}=c(10);b[f++]=215,b[f++]=255,e.setUint32(f,4e6*a.getMilliseconds()+(d/1e3/4294967296>>0)),e.setUint32(f+4,d)}else{// Timestamp 96
let{target:e,targetView:f,position:g}=c(15);e[g++]=199,e[g++]=12,e[g++]=255,f.setUint32(g,1e6*a.getMilliseconds()),f.setBigInt64(g+4,BigInt(b(d)))}}},{pack(a,b,c){let d=Array.from(a),{target:e,position:f}=b(this.structuredClone?3:0);this.structuredClone&&(e[f++]=212,e[f++]=115,e[f++]=0),c(d)}},{pack(a,b,c){let{target:d,position:e}=b(this.structuredClone?3:0);this.structuredClone&&(d[e++]=212,d[e++]=101,d[e++]=0),c([a.name,a.message])}},{pack(a,b,c){let{target:d,position:e}=b(this.structuredClone?3:0);this.structuredClone&&(d[e++]=212,d[e++]=120,d[e++]=0),c([a.source,a.flags])}},{pack(a,b){this.structuredClone?r(a,16,b):s(ha?Buffer.from(a):new Uint8Array(a),b)}},{pack(a,b){let c=a.constructor;c!==ja&&this.structuredClone?r(a,Z.indexOf(c.name),b):s(a,b)}},{pack(a,b){// specific 0xC1 object
let{target:c,position:d}=b(1);c[d]=193}}];let ra=new qa({useRecords:!1});const sa=ra.pack,ta=ra.pack,{NEVER:ua,ALWAYS:va,DECIMAL_ROUND:wa,DECIMAL_FIT:xa}=da;a.ALWAYS=va,a.C1=M,a.DECIMAL_FIT=xa,a.DECIMAL_ROUND=wa,a.Decoder=O,a.Encoder=qa,a.FLOAT32_OPTIONS=da,a.NEVER=ua,a.Packr=qa,a.Unpackr=O,a.addExtension=v,a.clearSource=p,a.decode=ca,a.decodeIter=function(a,b={}){if(!a||"object"!=typeof a)throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise");const c=new O(b);let d;const e=a=>{let b;// if there's incomplete data from previous chunk, concatinate and try again
d&&(a=Buffer.concat([d,a]),d=void 0);try{b=c.unpackMultiple(a)}catch(c){if(c.incomplete)d=a.slice(c.lastPosition),b=c.values;else throw c}return b};if("function"==typeof a[Symbol.iterator])return function*(){for(const b of a)yield*e(b)}();return"function"==typeof a[Symbol.asyncIterator]?async function*(){for await(const b of a)yield*e(b)}():void 0},a.encode=ta,a.encodeIter=/**
	 * Given an Iterable first argument, returns an Iterable where each value is packed as a Buffer
	 * If the argument is only Async Iterable, the return value will be an Async Iterable.
	 * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object
	 * @param {options} [options] - msgpackr pack options
	 * @returns {IterableIterator|Promise.<AsyncIterableIterator>}
	 */function(a,b={}){if(!a||"object"!=typeof a)throw new Error("first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable");else{if("function"==typeof a[Symbol.iterator])return w(a,b);if("function"==typeof a.then||"function"==typeof a[Symbol.asyncIterator])return x(a,b);throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise")}},a.mapsAsObjects=!0,a.pack=sa,a.unpack=aa,a.unpackMultiple=ba,a.useRecords=!1,Object.defineProperty(a,"__esModule",{value:!0})});
